<?php
/**
 * @file
 * Base file for the loft_core module.
 *
 * @defgroup loft_core Loft Core
 * @{
 */
use Drupal\loft_core\Redirect;

//
//
// Register hook_boot ONLY if we are using the autoload feature.
//
if (!empty($GLOBALS['conf']['loft_core_autoload'])) {
    /**
     * Implements hook_boot().
     */
    function loft_core_boot()
    {
        // You must load the composer autoload in this fashion.
        include_once dirname(__FILE__) . '/vendor/autoload.php';
    }
}

/**
 * Menu callback: Displays a single node, but checks for a redirect first.
 *
 * @param $node
 *   The node object.
 *
 * @return
 *   A page array suitable for use by drupal_render().
 *
 * @see node_menu()
 */
function loft_core_node_page_view($node)
{
    // When viewing this node in page view, check to see if we're to redirect it instead.
    if (($redirect = Redirect::getNodeMenuObjectRedirect())) {
        switch ($redirect['page callback']) {
            case 'drupal_not_found':
                return MENU_NOT_FOUND;
            case 'drupal_access_denied':
                return MENU_ACCESS_DENIED;
            default:
                call_user_func_array($redirect['page callback'], $redirect['page arguments']);
                break;
        }
    }

    // ... otherwise do the normal.
    return node_page_view($node);
}

function loft_core_menu_alter(&$items)
{
    if (isset($items['node/%node'])) {
        $items['node/%node']['page callback'] = 'loft_core_node_page_view';
    }
}

/**
 * Implements hook_form_alter().
 *
 * Make sure we don't redirect admins after editing a "redirected" node.
 */
function loft_core_form_node_form_alter(&$form, &$form_state)
{
    if (Redirect::isNodeRedirected($form_state['node'])) {
        $form['actions']['submit']['#submit'][] = 'loft_core_node_form_submit_redirect_handler';
    }
}

/**
 * Redirect a node form to the edit page, no the view page as normal.
 *
 * @param $form
 * @param $form_state
 */
function loft_core_node_form_submit_redirect_handler($form, &$form_state)
{
    if (!empty($form_state['redirect']) && $form_state['nid']) {
        $form_state['redirect'] = node_access('update', $form_state['nid']) ? 'node/' . $form_state['nid'] . '/edit' : '<front>';
    }
}

/**
 * Adds a tabindex to a form element
 *
 * @param array &$element The form element to add to.
 * @param null  $index    You can omit and each subsequent call will increment.
 *
 * @return int The next tabindex available.
 *
 * Near the bottom of the form do something like this
 * @code
 *   loft_core_form_tabindex($form['title'], 100);
 *   loft_core_form_tabindex($form['actions']['create']);
 *   loft_core_form_tabindex($form['actions']['cancel']);
 * @endcode
 */
function loft_core_form_tabindex(array &$element, $index = null)
{
    static $tabindex = 1;
    if ($index) {
        $tabindex = $index;
    }
    $element['#attributes']['tabindex'] = $tabindex;

    return ++$tabindex;
}


/**
 * Disable an array of form elements with a consistent message.
 *
 * @code
 * $paths = array();
 * $paths[] = 'field_description.und.0';
 * $paths[] = 'field_keywords.und';
 * loft_core_form_disable_elements($form, $paths);
 * @endcode
 *
 * @param array  &$form
 * @param array  $paths       An array of paths to be used by data_api().
 * @param string $module_name This will be used in the default message.
 * @param null   $message     If the default message is not sufficient, enter a
 *                            custom message here.
 */
function loft_core_form_disable_elements(&$form, $paths, $module_name = null, $message = null)
{
    $g = data_api();
    if (is_null($message)) {
        $module_name = empty($module_name) ? 'Loft Core' : $module_name;
        $message = t('This field is controlled by the %module module and cannot be modified in the UI.', array('%module' => $module_name));
    }
    foreach ($paths as $path) {
        if ($g->get($form, $path)) {
            $type = $g->get($form, "$path.#type");
            $g->set($form, "$path.#disabled", true);
            switch ($type) {
                case 'container':
                    $message_path = "$path.#suffix";
                    break;
                default:
                    $message_path = "$path.#description";
                    break;
            }
            $g->set($form, $message_path, $message);
        }
    }
}

function loft_core_form_hide_elements(&$form, $paths)
{
    $g = data_api();
    foreach ($paths as $path) {
        if ($g->get($form, $path)) {
            $g->set($form, "$path.#access", false);
        }
    }
}

/**
 * Implements hook_element_info().
 */
function loft_core_element_info()
{
    $types = array();
    $types['form_help'] = array(
        '#weight'         => -99,
        // string|array If array, elements are separate paragraphs, without <p> tag wrappers.
        '#message'        => array(),
        '#theme_wrappers' => array('form_help', 'form_element'),
    );

    return $types;
}

/**
 * Return the maximum weight in a render array, top level only.
 *
 * @param $render_array
 *
 * @return int
 */
function loft_core_max_weight($render_array)
{
    $max = 0;
    array_walk($render_array, function ($value) use (&$max) {
        $max = max($max, data_api()->get($value, '#weight', 0));
    });

    return $max;
}

/**
 * Return the minimum weight in a render array, top level only.
 *
 * @param $render_array
 *
 * @return int
 */
function loft_core_min_weight($render_array)
{
    $min = 0;
    array_walk($render_array, function ($value) use (&$min) {
        $min = min($min, data_api()->get($value, '#weight', 0));
    });

    return $min;
}

function loft_core_theme($existing, $type, $theme, $path)
{
    return array(
        'form_help' => array(
            'render element' => 'element',
        ),
    );
}

/**
 * Implements hook_preprocess_form_help().
 */
function loft_core_preprocess_form_help(&$vars)
{
    $element =& $vars['element'];

    // Wrap all elements of #message in p tags, if array.
    if (is_array($element['#message'])) {
        array_walk($element['#message'], function (&$value) {
            if (strpos($value, '<p') !== 0) {
                $value = '<p>' . $value . '</p>';
            }
        });
        $element['#message'] = implode('', $element['#message']);
    }
}


/**
 * Provides output for form help..
 *
 * @param array $vars
 *
 * @return string
 *
 * @ingroup themeable
 */
function theme_form_help($vars)
{
    $element = $vars['element'];
    $element['#attributes']['class'][] = 'form-help';

    return '<div' . drupal_attributes($element['#attributes']) . '>' . $element['#message'] . $element['#children'] . '</div>';
}

/**
 * Callback for #post_render to add a cache-busting token to image derivatives.
 *
 * This example shows how to add a cache buster to a certain node image field
 * when the user is logged in to the website.
 *
 * @code
 *   function HOOK_node_view_alter(&$build)
 *   {
 *       if (!empty($build['product:field_image']) && user_is_logged_in()) {
 *           $build['product:field_image']['#post_render'][] =
 *           'loft_core_image_src_itok_cache_buster';
 *       }
 *   }
 * @endcode
 *
 * @param string $html  Expecting to contain ?itok=123"
 * @param array  $build Expecting to find:
 *                      - #object->changed
 *
 * @return string The modified html
 */
function loft_core_image_src_itok_cache_buster($html, $build)
{
    global $user;
    $buster = array(
        0 => variable_get('loft_core_cache_bust_token', 'cb'),
        1 => null,
    );
    if ((!empty($build['#object']->changed))) {
        $buster[1] = $build['#object']->changed;
    }
    elseif ((!empty($user->access))) {
        $buster[1] = $user->access;
    }
    else {
        $buster[1] = time();
    }
    $regex = '/' . preg_quote(IMAGE_DERIVATIVE_TOKEN) . '[^"]+/';
    $html = preg_replace($regex, '$0&' . implode('=', $buster), $html);

    return $html;
}

/**
 * Invokes a hook on the default them if that implements it.
 *
 * @param $hook
 *   The name of the hook to invoke.
 * @param ...
 *   Arguments to pass to the hook.
 *
 * @return
 *   An array of return values of the hook implementations. If the theme returns
 *   arrays from it's implementation, those are merged into one array
 *   recursively. Note: integer keys in arrays will be lost, as the merge is
 *   done using array_merge_recursive().
 *
 * @see   drupal_alter()
 */
//function theme_invoke($hook)
//{
//    if (!($theme = variable_get('theme_default', null))) {
//        return;
//    }
//    $args = func_get_args();
//    // Remove $hook from the arguments.
//    unset($args[0]);
//    $return = array();
//
//    $function = $theme . '_' . $hook;
//    if (function_exists($function)) {
//        $result = call_user_func_array($function, $args);
//        if (isset($result) && is_array($result)) {
//            $return = array_merge_recursive($return, $result);
//        }
//        elseif (isset($result)) {
//            $return[] = $result;
//        }
//    }
//
//    return $return;
//}

/**
 * Test if a feature is live.
 *
 * If $feature is not registered it defaults to live.
 *
 * @param string $feature The id of the feature as declared by
 *                        HOOK_loft_core_features_switch().
 *
 * @return bool
 */
function is_live($feature)
{
    static $features = null;
    if (is_null($features)) {
        $features = module_invoke_all('loft_core_code_release_info');
        $features[$feature]['is_live'] = isset($features[$feature]) ? $features[$feature]['is_live'] : true;
    }

    return $features[$feature]['is_live'];
}


/**
 * Provides a test css class when environment is not prod.
 *
 * @param string $class
 *
 * @return string
 */
function loft_test_class($class)
{
    if (in_array(DRUPAL_ENV, ['local', 'local_devserver'])) {
        return 't-' . $class;
    }
}
