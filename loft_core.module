<?php
/**
 * @file
 * Base file for the loft_core module.
 *
 * @defgroup loft_core Loft Core
 * @{
 */

use Drupal\Core\Template\Attribute;
use Drupal\Core\Url;
use Drupal\loft_core\StaticContentStreamWrapper;
use Drupal\loft_core\Utility\RenderInPageBottom;
use Drupal\loft_core_testing\Component\Utility\TestingMarkup;

require_once dirname(__FILE__) . '/includes/loft_core.forms.inc';
require_once dirname(__FILE__) . '/includes/loft_core.ajax.inc';
require_once dirname(__FILE__) . '/includes/loft_core.utilities.inc';

/**
 * Test if a feature is live.
 *
 * If $feature is not registered it defaults to live.
 *
 * @param string $feature The id of the feature as declared by
 *                        HOOK_loft_core_features_switch().
 *
 * @return bool
 */
function is_live($feature) {
  static $features = NULL;
  if (is_null($features)) {
    $features = \Drupal::moduleHandler()
      ->invokeAll('loft_core_code_release_info');
    $features[$feature]['is_live'] = isset($features[$feature]) ? $features[$feature]['is_live'] : TRUE;
  }

  return $features[$feature]['is_live'];
}

/**
 * Provides a test css class when environment is not prod.
 *
 * @param string $class
 *
 * @return string
 *
 * @deprecated Use TestingMarkup::id instead.
 */
function loft_core_test_class(string $class): string {
  static $testing;
  if (TestingMarkup::isTesting()) {

    // First time on page load that we get here, we may delete the expiry.
    if (!$testing && !empty($expiry) && $expiry < time()) {
      \Drupal::state()->delete('loft_core_test_mode_expiry');
    }
    $testing = TRUE;

    return 't-' . $class;
  }

  return '';
}

/**
 * Add test classes to element children.
 *
 * This will only add the classes if the elements exist, so this is a very
 * handy shortcut function for processing forms.
 *
 * @code
 *   loft_core_element_add_test_classes($form, [
 *     'field_account_type.widget',
 *     'account.mail as mail',
 *   ]);
 * @endcode
 *
 * The previous code will yield the following values in the form:
 * @code
 *   $form['field_account_type']['widget']['#attributes']['class'][0] =
 *   't-field_account-type';
 *   $form['account']['mail']['#attributes']['class'][0] = 't-mail';
 * @endcode
 *
 * @param array &$element
 *   A render element, usually a form.
 * @param array $paths
 *   An indexed array with one or more items that point to a key path inside of
 *   $element, e.g. 'field_account_name.widget.0.value'.  The #attributes key
 *   will be added as a child of this path.  The test class is the substring up
 *   to and not including the first '.' in the path; in the example just given,
 *   the test class will be built on 'field_account_name'. In cases where you
 *   want to specify the test class, you can use ' as [test class]', e.g.
 *   'field_account_name.widget.0.value as account_name' for the array item
 *   value.
 */
function loft_core_element_add_test_classes(array &$element, array $paths): void {
  $g = data_api();
  foreach ($paths as $path) {
    list($path, $test_class) = explode(' as ', $path . ' as ' . $path);
    list($test_class) = explode('.', $test_class);
    $exists = FALSE;
    $g->onlyIfHas($element, $path)->call(function () use (&$exists) {
      $exists = TRUE;
    });
    if ($exists) {
      $s = data_api();
      $path .= '.#attributes.class';
      $classes = $s->get($element, $path, []);
      $classes[] = TestingMarkup::id($test_class);
      $s->set($element, $path, $classes);
    }
  }
}

/**
 * Implements hook_js_settings_build().
 */
function loft_core_js_settings_build(array &$settings, \Drupal\Core\Asset\AttachedAssetsInterface $assets) {
  $settings['env'] = [
    'env' => DRUPAL_ENV,
    'prod' => DRUPAL_ENV_PROD,
    'staging' => DRUPAL_ENV_STAGING,
    'dev' => DRUPAL_ENV_DEV,
  ];
}

//
// ANYTHING ABOVE HERE HAS BEEN PORTED TO D8.
//
//
//
//
//
//
//
//

/**
 * Implements hook_preprocess_html().
 */
function loft_core_preprocess_html(&$vars) {
  $user = \Drupal::currentUser();
  $vars['loft_core_tracking'] = '';
  if (DRUPAL_ENV === 'prod' && ($token = \Drupal::config('loft_core.settings')
      ->get('loft_core_trackjs_token'))) {

    // @link http://docs.trackjs.com/tracker/configuration
    $trackjs = [
      'config' => '',
      'metadata' => [],
    ];

    $trackjs['config']['token'] = $token;

    if (function_exists('web_package_get_version')) {
      $trackjs['config']['version'] = web_package_get_version();
    }

    // TrackJS allows you to track errors for multiple applications from the same account.
    // See the UI documentation for how to setup applications.
    $trackjs['config']['application'] = NULL;

    // If you have some identifiable string that represents a user or customer,
    //please include it.
    // In the TrackJS UI we allow you to group and filter by this value.
    $trackjs['config']['userId'] = \Drupal::currentUser()
      ->isAuthenticated() ? $user->uid : NULL;
    $trackjs['metadata']['username'] = \Drupal::currentUser()
      ->isAuthenticated() ? $user->name : NULL;

    // Similar to userId,
    //if you have a session guid or something you can set it here.
    // We allow you to search on this value in the UI.
    $trackjs['config']['sessionId'] = session_id();

    \Drupal::moduleHandler()->alter('loft_core_trackjs', $trackjs);

    $config = json_encode(array_filter($trackjs['config']));

    $meta = [];
    foreach (array_filter($trackjs['metadata']) as $key => $value) {
      $meta[] = 'trackJs.addMetadata("' . $key . '",
            "' . $value . '");';
    }
    $meta = implode(';',
      $meta);
    $vars['loft_core_tracking'] = <<<EOD
<!-- BEGIN TRACKJS -->
<script type="text/javascript">window._trackJs = {$config};</script>
<script type="text/javascript" src="https://cdn.trackjs.com/releases/current/tracker.js"></script>
<script type="text/javascript">{$meta};</script>
<!-- END TRACKJS -->
EOD;
  }
}

/**
 * @FIXME
 * This implementation of hook_menu() cannot be automatically converted because
 * it contains logic (i.e., branching statements, function calls, object
 * instantiation, etc.) You will need to convert it manually. Sorry!
 *
 * For more information on how to convert hook_menu() to Drupal 8's new routing
 * and linking systems, see
 *   https://api.drupal.org/api/drupal/core%21includes%21menu.inc/group/menu/8
 */
function loft_core_menu() {
  $items[StaticContentStreamWrapper::URL_BASE] = [
    'type' => MENU_CALLBACK,
    'title' => 'Raw static content',
    'page callback' => 'loft_core_static_content_stream',
    'access arguments' => ['access raw static content'],
  ];

  return $items;
}


/**
 * Stream a static-content file.
 *
 * @param string $target
 *   The target static content file relative to the static content directory.
 */
function loft_core_static_content_stream($target) {
  $uri = 'static-content://' . $target;
  if (file_exists($uri)) {
    $headers = [];
    file_transfer($uri, $headers);
    drupal_access_denied();
  }
  else {
    drupal_not_found();
  }
  drupal_exit();
}

/**
 * Implements hook_element_info().
 */
function loft_core_element_info() {
  $types = [];
  $types['form_help'] = [
    '#weight' => -99,

    // string|array If array,
    //elements are separate paragraphs,
    //without <p> tag wrappers.
    '#message' => [],
    '#theme_wrappers' => [
      'form_help',
      'form_element',
    ],
  ];

  return $types;
}

/**
 * Implements hook_theme().
 *
 * @d8
 */
function loft_core_theme($existing, $type, $theme, $path) {
  return [
    'form_help' => [
      'function' => 'theme_form_help',
      'render element' => 'element',
    ],
  ];
}

/**
 * Implements hook_preprocess_form_help().
 *
 * @d8
 */
function loft_core_preprocess_form_help(&$vars) {
  $element =& $vars['element'];

  // Wrap all elements of #message in p tags,
  //if array.
  if (is_array($element['#message'])) {
    array_walk($element['#message'],
      function (&$value) {
        if (strpos($value,
            '<p') !== 0
        ) {
          $value = '<p>' . $value . '</p>';
        }
      });
    $element['#message'] = implode('',
      $element['#message']);
  }
}


/**
 * Provides output for form help.
 *
 * DO NOT CALL DIRECTLY USE ['#type' => 'form_help',...] INSTEAD!
 *
 * @ingroup themeable
 *
 * @d8
 */
function theme_form_help($vars) {
  $element = $vars['element'];
  $attributes = new Attribute($element['#attributes']);

  return '<blockquote' . $attributes . '>' . $element['#message'] . $element['#children'] . '</blockquote>';
}


/**
 * Invokes a hook on the default them if that implements it.
 *
 * @param $hook
 *   The name of the hook to invoke.
 * @param ...
 *   Arguments to pass to the hook.
 *
 * @return
 *   An array of return values of the hook implementations. If the theme returns
 *   arrays from it's implementation,
 * those are merged into one array
 *   recursively. Note: integer keys in arrays will be lost,
 * as the merge is
 *   done using array_merge_recursive().
 *
 * @see   drupal_alter()
 */
//function theme_invoke($hook)
//{
//    if (!($theme = variable_get('theme_default',
//null))) {
//        return;
//    }
//    $args = func_get_args();
//    // Remove $hook from the arguments.
//    unset($args[0]);
//    $return = array();
//
//    $function = $theme . '_' . $hook;
//    if (function_exists($function)) {
//        $result = call_user_func_array($function,
//$args);
//        if (isset($result) && is_array($result)) {
//            $return = array_merge_recursive($return,
//$result);
//        }
//        elseif (isset($result)) {
//            $return[] = $result;
//        }
//    }
//
//    return $return;
//}


/**
 * Adds commands echoing all drupal messages to trackjs
 *
 * Place this in an ajax response function where you have access to the
 * $commands array that is being build for the response.s
 *
 * @param array &$commands
 * @param array $severities Which drupal_get_messages() severity levels to
 *                          send.  Defaults to warning and error.
 *
 * @see _loft_core_trackjs_get_severities().
 */
function loft_core_trackjs_echo_drupal_messages(array &$commands, array $severities = [
  'warning',
  'error',
]
) {
  $groups = \Drupal::messenger()->all();
  foreach ($groups as $level => $messages) {
    if (!in_array($level, $severities)) {
      continue;
    }
    switch ($level) {
      case 'warning':
        $trackjs_level = 'warn';
        break;
      case 'error':
        $trackjs_level = 'error';
        break;
      default:
        $trackjs_level = 'info';
        break;
    }
    foreach ($messages as $message) {
      $commands[] = loft_core_ajax_command_trackjs_console($trackjs_level,
        $message);
    }
  }
}


/**
 * Stash or unstash a user.
 *
 * This function:
 * - allows you to run some code as a different user inside of a callback
 * function, in which case you need simple call it once with $temporary_user
 * and $callback.
 * - allows you to set a temporary user for a time until you call this function
 * again.  Unless you call this function again, the temporary user will become
 * the logged in user, so USE WITH CARE.
 *
 * The stashed users will persist in the SESSION.
 *
 * @param null $temporary_user Leave null when unstashing a previously stashed
 *   user.
 * @param callable|NULL $callback
 */
function loft_core_user_stash($temporary_user = NULL, callable $callback = NULL) {
  $user = \Drupal::currentUser();
  static $stashed = NULL;
  $needs_unstash = is_null($temporary_user);

  if ($temporary_user) {
    if ($stashed) {
      throw new \RuntimeException("A user has already been stashed; you must unstash before you try to stash another user.");
    }
    $needs_unstash = FALSE;
    $stashed = $user;
    $user = $temporary_user;

    // When callback is provided, we unstash post $callback.
    if ($callback) {
      $callback();
      $needs_unstash = TRUE;
    }
  }

  if ($stashed && $needs_unstash) {
    $user = $stashed;
    $stashed = NULL;
  }
}

/**
 * Implements hook_preprocess_status_report().
 */
function loft_core_preprocess_status_report(&$vars) {
  $unset = NULL;
  array_walk($vars['requirements'], function (&$item, $key) use (&$unset) {
    if ($item['title'] !== 'Update notifications') {
      return;
    }

    //
    //
    // ITLS wants updates module disabled on prod since I monitor client updates using another system. And we don't
    // want clients to think there is a problem so we hide the default warning when update is disabled.
    //
    // @FIXME
    // // @FIXME
    // // This looks like another module's variable. You'll need to rewrite this call
    // // to ensure that it uses the correct configuration object.
    // $allows_ftp_updates = variable_get('allow_authorize_operations', TRUE);

    if ($allows_ftp_updates) {
      $item = [
        'title' => '$allow_authorize_operations',
        'description' => t('If you are using GIT you should add this line to <em>settings.php</em>: <code>$conf[\'allow_authorize_operations\'] = FALSE;</code>'),
        'value' => 'true',
        'severity' => REQUIREMENT_ERROR,
      ];
    }
    elseif (DRUPAL_ENV === DRUPAL_ENV_PROD && $item['value'] === t('Enabled')) {
      $item['severity'] = REQUIREMENT_WARNING;
      $item['description'] = t('Update module should not be enabled on production as updates are handled by ITLS.');
    }
    elseif (isset($item['severity']) && $item['severity'] === REQUIREMENT_WARNING) {
      $unset = $key;
    }
  });

  if ($unset) {
    unset($vars['requirements'][$unset]);
  }
}

/**
 * Implements hook_stream_wrappers().
 */
function loft_core_stream_wrappers() {

  // This is here to address an issue of missing class when using drush updb.
  if (!class_exists('\Drupal\loft_core\StaticContentStreamWrapper')) {
    module_load_include('php', 'loft_core', 'src/Drupal/loft_core/StaticContentStreamWrapper');
  }

  $wrappers = [
    'static-content' => [
      'name' => t('Static content'),
      'class' => '\Drupal\loft_core\StaticContentStreamWrapper',
      'description' => t("Content that should not be exposed to the CMS, but included in the final output."),
    ],
  ];

  return $wrappers;
}

/**
 * Implements hook_menu_links_discovered_alter().
 */
function loft_core_menu_links_discovered_alter(array &$links) {
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function loft_core_menu_local_tasks_alter(array &$data, $route_name) {
}

/**
 * Implements hook_menu_local_actions_alter().
 */
function loft_core_menu_local_actions_alter(array &$local_actions) {
}

/**
 * Implements hook_contextual_links_view_alter().
 */
function loft_core_contextual_links_view_alter(array &$element, array $items) {
  $id = NULL;
  foreach ($items as $item) {
    if (isset($item['route_parameters']['node'])) {
      $id = $item['route_parameters']['node'];
      $url = Url::fromRoute('entity.node.canonical', ['node' => $id]);
      break;
    }
  }

  if ($id) {
    $element['#links'] = array_merge(
      [
        'loft_core_id' => [
          'title' => $id,
          'url' => $url,
        ],
      ],
      $element['#links'],
    );
  }

}

/**
 * Implements HOOK_preprocess_status_messages().
 *
 * Remove any messages suppressed by loft_core_suppress_messages.
 */
function loft_core_preprocess_status_messages(&$vars) {
  // TODO Fix this fails at /admin/structure/webform/manage/earthrise_discussion_guide/settings
  return;
  if ($vars['message_list'] && ($masks = \Drupal::moduleHandler()
      ->invokeAll('loft_core_suppress_messages'))) {
    foreach (array_keys($masks) as $type) {
      if (isset($vars['message_list'][$type])) {
        foreach ($vars['message_list'][$type] as $key => $message) {
          foreach ($masks[$type] as $mask) {
            if (preg_match($mask, $message)) {
              unset($vars['message_list'][$type][$key]);
            }
          }
        }
      }
      $vars['message_list'] = array_filter($vars['message_list']);
    };
  }
}

/**
 * Implements hook_page_bottom().
 */
function loft_core_page_bottom(&$page_bottom) {
  $page_bottom['render_in_page_bottom'] = [
    '#pre_render' => [[RenderInPageBottom::class, 'get']],
  ];
}

/**
 * Implements hook_preprocess_links__dropbutton__operations__paragraphs().
 *
 * Put all paragraphs in alphabetical order.
 */
function loft_core_preprocess_links__dropbutton__operations__paragraphs(&$vars) {
  uasort($vars['links'], function ($a, $b) {
    return strcasecmp((string) $a['text']['#value'], (string) $b['text']['#value']);
  });
}

/**
 * Implements hook_preprocess_menu_local_task().
 */
function loft_core_preprocess_menu_local_task(&$vars) {
  $route_name = $vars['link']['#url']->getRouteName();
  if (!in_array($route_name, [
    'loft_core.node.permalink',
    'loft_core.node.local_link',
  ])) {
    return;
  }

  $is_absolute = $route_name === 'loft_core.node.permalink';

  $vars['#attached']['library'][] = 'loft_core/clipboard';
  $vars['link']['#url']
    ->setOption('path_processing', FALSE)
    ->setOption('absolute', $is_absolute);
  $vars['link']['#options']['attributes']['data-loft-core-clipboard'] = $vars['link']['#url']->toString();
  $vars['link']['#options']['attributes']['data-loft-core-clipboard-confirm'] = t('Copied!', ['@value' => $vars['link']['#url']->toString()]);
  $vars['link']['#options']['attributes']['data-loft-core-clipboard-confirm-duration'] = 2000;

  // It's awkward to see the View tab and both of these tabs all active at the
  // same time, due to the shared route id.  So let's not make these active.
  $vars['link']['#options']['set_active_class'] = FALSE;
}
