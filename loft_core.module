<?php
/**
 * @file
 * Base file for the loft_core module.
 *
 * @defgroup loft_core Loft Core
 * @{
 */
use Drupal\loft_core\Attribute;
use Drupal\loft_core\Redirect;

//
//
// Register hook_boot ONLY if we are using the autoload feature.
//
if (!empty($GLOBALS['conf']['loft_core_autoload'])) {
    /**
     * Implements hook_boot().
     */
    function loft_core_boot()
    {
        // You must load the composer autoload in this fashion.
        include_once dirname(__FILE__) . '/vendor/autoload.php';
    }
}

/**
 * Implements hook_init().
 */
function loft_core_init()
{
    drupal_add_js(array(
        'DRUPAL_ENV' => DRUPAL_ENV,
        'DRUPAL_ENV_ROLE' => DRUPAL_ENV_ROLE,
    ), 'setting');
    drupal_add_js(drupal_get_path('module',
            'loft_core') . '/loft_core.js',
        array(
            'scope' => 'header',
            'group' => JS_DEFAULT,
        ),
        'file');
}

/**
 * Implements hook_preprocess_html().
 */
function loft_core_preprocess_html(&$vars)
{
    global $user;
    $vars['loft_core_tracking'] = '';
    if (DRUPAL_ENV_ROLE === 'prod' && ($token = variable_get('loft_core_trackjs_token',
            null))
    ) {

        // @link http://docs.trackjs.com/tracker/configuration
        $trackjs = array(
            'config' => '',
            'metadata' => [],
        );

        $trackjs['config']['token'] = $token;

        if (function_exists('web_package_get_version')) {
            $trackjs['config']['version'] = web_package_get_version();
        }

        // TrackJS allows you to track errors for multiple applications from the same account.
        // See the UI documentation for how to setup applications.
        $trackjs['config']['application'] = null;

        // If you have some identifiable string that represents a user or customer,
        //please include it.
        // In the TrackJS UI we allow you to group and filter by this value.
        $trackjs['config']['userId'] = user_is_logged_in() ? $user->uid : null;
        $trackjs['metadata']['username'] = user_is_logged_in() ? $user->name : null;

        // Similar to userId,
        //if you have a session guid or something you can set it here.
        // We allow you to search on this value in the UI.
        $trackjs['config']['sessionId'] = session_id();

        drupal_alter('loft_core_trackjs',
            $trackjs);

        $config = json_encode(array_filter($trackjs['config']));

        $meta = array();
        foreach (array_filter($trackjs['metadata']) as $key => $value) {
            $meta[] = 'trackJs.addMetadata("' . $key . '",
            "' . $value . '");';
        }
        $meta = implode(';',
            $meta);
        $vars['loft_core_tracking'] = <<<EOD
<!-- BEGIN TRACKJS -->
<script type="text/javascript">window._trackJs = {$config};</script>
<script type="text/javascript" src="https://cdn.trackjs.com/releases/current/tracker.js"></script>
<script type="text/javascript">{$meta};</script>
<!-- END TRACKJS -->        
EOD;
    }
}

/**
 * Menu callback: Displays a single node,
 * but checks for a redirect first.
 *
 * @param $node
 *   The node object.
 *
 * @return
 *   A page array suitable for use by drupal_render().
 *
 * @see node_menu()
 *
 *
 * // TODO Support node create?
 */
function loft_core_node_page($node,
                             $op
) {
    if (is_string($node)) {
        switch ($node) {
            case 'node_delete_confirm':
                $form_id = $node;
                $node = $op;
                $op = 'delete';
                break;
        }
    }

    //
    //
    // First check for a BUNDLE_TYPE_page...
    //
    if ($op === 'view') {
        $type = $node->type;
        $hook = 'loft_core_node_' . $type . '_page';
        if (($modules = module_implements($hook))) {
            // We only take the last one.
            $callback = end($modules) . '_' . $hook;

            return $callback($node);
        }
    }

    //
    //
    // ... then look for a redirect.
    //
    if (($redirect = Redirect::getNodeMenuObjectRedirect($op))) {
        switch ($redirect['page callback']) {
            case 'drupal_not_found':
                return MENU_NOT_FOUND;
            case 'drupal_access_denied':
                return MENU_ACCESS_DENIED;
            default:
                call_user_func_array($redirect['page callback'],
                    $redirect['page arguments']);
                break;
        }
    }

    // ... otherwise do the normal.
    switch ($op) {
        case 'delete':
            return drupal_get_form($form_id,
                $node);
        default:
            $func = "node_page_{$op}";

            return $func($node);
    }
}

function loft_core_menu_alter(&$items)
{
    $key = 'node/%node';
    if (isset($items[$key])) {
        $items[$key]['page callback'] = 'loft_core_node_page';
        $items[$key]['page arguments'][] = 'view';
    }
    $key = 'node/%node/view';
    if (isset($items[$key])) {
        $items[$key]['page callback'] = 'loft_core_node_page';
        $items[$key]['page arguments'][] = 'view';
    }
    $key = 'node/%node/edit';
    if (isset($items[$key])) {
        $items[$key]['page callback'] = 'loft_core_node_page';
        $items[$key]['page arguments'][] = 'edit';
    }
    $key = 'node/%node/delete';
    if (isset($items[$key])) {
        $items[$key]['page callback'] = 'loft_core_node_page';
        $items[$key]['page arguments'][] = 'delete';
    }
}

/**
 * Implements hook_form_alter().
 *
 * Make sure we don't redirect admins after editing a "redirected" node.
 */
function loft_core_form_node_form_alter(&$form,
                                        &$form_state
) {
    if (Redirect::isNodeRedirected($form_state['node'],
        'view')
    ) {
        $form['actions']['submit']['#submit'][] = 'loft_core_node_form_submit_redirect_handler';
    }
}

/**
 * Redirect a node form to the edit page,
 * no the view page as normal.
 *
 * @param $form
 * @param $form_state
 */
function loft_core_node_form_submit_redirect_handler($form,
                                                     &$form_state
) {
    if (!empty($form_state['redirect']) && $form_state['nid']) {
        $form_state['redirect'] = node_access('update',
            $form_state['nid']) ? 'node/' . $form_state['nid'] . '/edit' : '<front>';
    }
}

/**
 * Adds a tabindex to a form element
 *
 * @param array  &$element The form element to add to.
 * @param int    $index    The next tabindex, will automatically be incremented.
 * @param string $key      What is the array key to add to? Defaults to
 *                         #attributes.
 *
 * @return int The next tabindex available.
 *
 * Near the bottom of the form do something like this
 * @code
 *   $tabindex = 100;
 *   loft_core_form_tabindex($form['title'], $tabindex);
 *   loft_core_form_tabindex($form['actions']['create'], $tabindex);
 *   loft_core_form_tabindex($form['actions']['cancel'], $tabindex);
 * @endcode
 */
function loft_core_form_tabindex(array &$element, &$index, $key = '#attributes'
) {
    $g = data_api();
    $g->ensure($element, $key, []);
    if ($element[$key] instanceof Attribute) {
        $element[$key]->setAttribute('tabindex', $index++);
    }
    else {
        $element[$key]['tabindex'] = $index++;
    }
}


/**
 * Disable an array of form elements with a consistent message.
 *
 * @code
 * $paths = array();
 * $paths[] = 'field_description.und.0';
 * $paths[] = 'field_keywords.und';
 * loft_core_form_disable_elements($form,
 * $paths);
 * @endcode
 *
 * @param array  &$form
 * @param array  $paths       An array of paths to be used by data_api().
 * @param string $module_name This will be used in the default message.
 * @param null   $message     If the default message is not sufficient,
 *                            enter a
 *                            custom message here.
 */
function loft_core_form_disable_elements(&$form,
                                         $paths,
                                         $module_name = null,
                                         $message = null
) {
    $g = data_api();
    if (is_null($message)) {
        $module_name = empty($module_name) ? 'Loft Core' : $module_name;
        $message = t('This field is controlled by the %module module and cannot be modified in the UI.',
            array('%module' => $module_name));
    }
    foreach ($paths as $path) {
        if ($g->get($form,
            $path)
        ) {
            $type = $g->get($form,
                "$path.#type");
            $g->set($form,
                "$path.#required",
                false);
            $g->set($form,
                "$path.#disabled",
                true);
            switch ($type) {
                case 'container':
                    $message_path = "$path.#suffix";
                    break;
                default:
                    $message_path = "$path.#description";
                    break;
            }
            $g->set($form,
                $message_path,
                $message);
        }
    }
}

function loft_core_form_hide_elements(&$form,
                                      $paths
) {
    $g = data_api();
    foreach ($paths as $path) {
        if ($g->get($form,
            $path)
        ) {
            $g->onlyIfHas($form,
                "$path.#required")->call(function () {
                return false;
            })->set($form);
            $g->set($form,
                "$path.#access",
                false);
        }
    }
}

/**
 * Implements hook_element_info().
 */
function loft_core_element_info()
{
    $types = array();
    $types['form_help'] = array(
        '#weight' => -99,
        // string|array If array,
        //elements are separate paragraphs,
        //without <p> tag wrappers.
        '#message' => array(),
        '#theme_wrappers' => array(
            'form_help',
            'form_element',
        ),
    );

    return $types;
}

/**
 * Return the maximum weight in a render array,
 * top level only.
 *
 * @param $render_array
 *
 * @return int
 */
function loft_core_max_weight($render_array)
{
    $max = 0;
    array_walk($render_array,
        function ($value) use (&$max) {
            $max = max($max,
                data_api()->get($value,
                    '#weight',
                    0));
        });

    return $max;
}

/**
 * Return the minimum weight in a render array,
 * top level only.
 *
 * @param $render_array
 *
 * @return int
 */
function loft_core_min_weight($render_array)
{
    $min = 0;
    array_walk($render_array,
        function ($value) use (&$min) {
            $min = min($min,
                data_api()->get($value,
                    '#weight',
                    0));
        });

    return $min;
}

function loft_core_theme($existing,
                         $type,
                         $theme,
                         $path
) {
    return array(
        'form_help' => array(
            'render element' => 'element',
        ),
    );
}

/**
 * Implements hook_preprocess_form_help().
 */
function loft_core_preprocess_form_help(&$vars)
{
    $element =& $vars['element'];

    // Wrap all elements of #message in p tags,
    //if array.
    if (is_array($element['#message'])) {
        array_walk($element['#message'],
            function (&$value) {
                if (strpos($value,
                        '<p') !== 0
                ) {
                    $value = '<p>' . $value . '</p>';
                }
            });
        $element['#message'] = implode('',
            $element['#message']);
    }
}


/**
 * Provides output for form help..
 *
 * @param array $vars
 *
 * @return string
 *
 * @ingroup themeable
 */
function theme_form_help($vars)
{
    $element = $vars['element'];
    $element['#attributes']['class'][] = 'form-help';

    return '<div' . drupal_attributes($element['#attributes']) . '>' . $element['#message'] . $element['#children'] . '</div>';
}

/**
 * Callback for #post_render to add a cache-busting token to image derivatives.
 *
 * This example shows how to add a cache buster to a certain node image field
 * when the user is logged in to the website.
 *
 * @code
 *   function HOOK_node_view_alter(&$build)
 *   {
 *       if (!empty($build['product:field_image']) && user_is_logged_in()) {
 *           $build['product:field_image']['#post_render'][] =
 *           'loft_core_image_src_itok_cache_buster';
 *       }
 *   }
 * @endcode
 *
 * @param string $html  Expecting to contain ?itok=123"
 * @param array  $build Expecting to find:
 *                      - #object->changed
 *
 * @return string The modified html
 */
function loft_core_image_src_itok_cache_buster($html,
                                               $build
) {
    global $user;
    $buster = array(
        0 => variable_get('loft_core_cache_bust_token',
            'cb'),
        1 => null,
    );
    if ((!empty($build['#object']->changed))) {
        $buster[1] = $build['#object']->changed;
    }
    elseif ((!empty($user->access))) {
        $buster[1] = $user->access;
    }
    else {
        $buster[1] = time();
    }
    $regex = '/' . preg_quote(IMAGE_DERIVATIVE_TOKEN) . '[^"]+/';
    $html = preg_replace($regex,
        '$0&' . implode('=',
            $buster),
        $html);

    return $html;
}

/**
 * Invokes a hook on the default them if that implements it.
 *
 * @param $hook
 *   The name of the hook to invoke.
 * @param ...
 *   Arguments to pass to the hook.
 *
 * @return
 *   An array of return values of the hook implementations. If the theme returns
 *   arrays from it's implementation,
 * those are merged into one array
 *   recursively. Note: integer keys in arrays will be lost,
 * as the merge is
 *   done using array_merge_recursive().
 *
 * @see   drupal_alter()
 */
//function theme_invoke($hook)
//{
//    if (!($theme = variable_get('theme_default',
//null))) {
//        return;
//    }
//    $args = func_get_args();
//    // Remove $hook from the arguments.
//    unset($args[0]);
//    $return = array();
//
//    $function = $theme . '_' . $hook;
//    if (function_exists($function)) {
//        $result = call_user_func_array($function,
//$args);
//        if (isset($result) && is_array($result)) {
//            $return = array_merge_recursive($return,
//$result);
//        }
//        elseif (isset($result)) {
//            $return[] = $result;
//        }
//    }
//
//    return $return;
//}

/**
 * Test if a feature is live.
 *
 * If $feature is not registered it defaults to live.
 *
 * @param string $feature The id of the feature as declared by
 *                        HOOK_loft_core_features_switch().
 *
 * @return bool
 */
function is_live($feature)
{
    static $features = null;
    if (is_null($features)) {
        $features = module_invoke_all('loft_core_code_release_info');
        $features[$feature]['is_live'] = isset($features[$feature]) ? $features[$feature]['is_live'] : true;
    }

    return $features[$feature]['is_live'];
}


/**
 * Provides a test css class when environment is not prod.
 *
 * @param string $class
 *
 * @return string
 */
function loft_core_test_class($class)
{
    if (defined('DRUPAL_ENV_ROLE') && strpos(DRUPAL_ENV_ROLE,
            'prod') !== 0
    ) {
        return 't-' . $class;
    }
}

/**
 * Use this to get a form during an ajax response; it suppressed the $_POST so
 * the form doesn't think it's already submitted.
 *
 * @param string $form_id
 *
 * @return array|mixed
 */
function loft_core_get_form_during_ajaxing($form_id)
{
    $stash = $_POST;
    $_POST = array();
    $form = drupal_get_form($form_id);
    $_POST = $stash;

    return $form;
}

/**
 * Send an ajax command to fire off trackjs.console.
 *
 * @param $severity One of 'log',
 *                  'debug',
 *                  'info',
 *                  'warn',
 *                  'error'
 * @param $message
 *
 * @return array
 *
 * @see  Drupal.ajax.prototype.commands.loftCoreTrackJsConsole().
 * @link http://docs.trackjs.com/tracker/top-level-api#trackjsconsole
 *
 * @throws InvalidArgumentException if $severity is not valid.
 */
function loft_core_ajax_command_trackjs_console($severity,
                                                $message
) {
    if (!in_array($severity,
        array('log', 'debug', 'info', 'warn', 'error'))
    ) {
        throw new \InvalidArgumentException("$severity must be one of: " . implode(',',
                $valid));
    }

    return array(
        'command' => 'loftCoreTrackJsConsole',
        'data' => array(
            'severity' => $severity,
            'message' => $message,
        ),
    );
}

/**
 * Adds commands echoing all drupal messages to trackjs
 *
 * Place this in an ajax response function where you have access to the
 * $commands array that is being build for the response.s
 *
 * @param array &$commands
 * @param array $severities Which drupal_get_messages() severity levels to
 *                          send.  Defaults to warning and error.
 *
 * @see _loft_core_trackjs_get_severities().
 */
function loft_core_trackjs_echo_drupal_messages(array &$commands,
                                                array $severities = array(
                                                    'warning',
                                                    'error',
                                                )
) {
    $groups = drupal_get_messages(null,
        false);
    foreach ($groups as $level => $messages) {
        if (!in_array($level, $severities)) {
            continue;
        }
        switch ($level) {
            case 'warning':
                $trackjs_level = 'warn';
                break;
            case 'error':
                $trackjs_level = 'error';
                break;
            default:
                $trackjs_level = 'info';
                break;
        }
        foreach ($messages as $message) {
            $commands[] = loft_core_ajax_command_trackjs_console($trackjs_level,
                $message);
        }
    }
}

/**
 * Return a function to use for SMACSS classes
 *
 * @code
 * $cl = loft_core_cl('my-base');
 * $class = $cl('title');
 *
 * $class === 'my-base__title';
 * @endcode
 *
 * @param string $base The SMACSS module base.
 *
 * @return callable
 */
function loft_core_cl($base)
{
    $base = preg_replace('/[_ ]/', '-', $base);

    return function ($name = '', $isComponent = true) use ($base) {
        $names = is_array($name) ? $name : [$name];
        $glue = $isComponent ? '_' : '-';
        $classes = [];
        foreach ($names as $name) {
            $classes[] = $base . ($name ? str_repeat($glue, 2) . $name : '');
        }

        return implode(' ', $classes);
    };
}

function loft_core_user_stash($stunt_double = null, $callback = null, $callback_args = [])
{
    global $user, $_loft_core_user_stash;

    // Unstash the user.
    if (is_null($stunt_double)) {
        if (!isset($_loft_core_user_stash)) {
            throw new \RuntimeException("You can't unstash a user that has not been stashed.");
        }

        $user = $_loft_core_user_stash;
        $_loft_core_user_stash = null;
    }

    // Stash the user.
    else {

        $_loft_core_user_stash = $user;
        $user = $stunt_double;
        if (is_callable($callback)) {
            $callback($callback_args);

            // for a callable we will immediately unstash.  If no callable we will assume a stash that will persist until function is called again.
            loft_core_user_stash();
        }
    }
}

/**
 * Implements hook_exit().
 */
function loft_core_exit()
{
    global $_loft_core_user_stash;

    // If the user has not been unstashed by now, we need to force it before drupal_session_commit() happens.
    if ($_loft_core_user_stash) {
        loft_core_user_stash();
    }
}
