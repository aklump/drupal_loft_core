<?php
/**
 * @file
 * Base file for the loft_core module.
 *
 * @defgroup loft_core Loft Core
 * @{
 */

use Drupal\loft_core\Redirect;
use Drupal\loft_core\StaticContentStreamWrapper;

// By default we will assume production environment.  To control or override this behavior see the documentation regarding these constants, e.g. settings.env.php, etc.
if (!defined('DRUPAL_ENV')) {
  define('DRUPAL_ENV', 'prod');
}
if (!defined('DRUPAL_ENV_ROLE')) {
  define('DRUPAL_ENV_ROLE', 'prod');
}

// These should already be defined in settings as of 7.x-0.3-rc26, but in case they're not.
if (!defined('DRUPAL_ENV_PROD')) {
  define('DRUPAL_ENV_PROD', 'prod');
}
if (!defined('DRUPAL_ENV_STAGING')) {
  define('DRUPAL_ENV_STAGING', 'staging');
}
if (!defined('DRUPAL_ENV_DEV')) {
  define('DRUPAL_ENV_DEV', 'dev');
}

require_once dirname(__FILE__) . '/includes/loft_core.forms.inc';
require_once dirname(__FILE__) . '/includes/loft_core.ajax.inc';
require_once dirname(__FILE__) . '/includes/loft_core.utilities.inc';

/**
 * Test if a feature is live.
 *
 * If $feature is not registered it defaults to live.
 *
 * @param string $feature The id of the feature as declared by
 *                        HOOK_loft_core_features_switch().
 *
 * @return bool
 */
function is_live($feature) {
  static $features = NULL;
  if (is_null($features)) {
    $features = \Drupal::moduleHandler()
      ->invokeAll('loft_core_code_release_info');
    $features[$feature]['is_live'] = isset($features[$feature]) ? $features[$feature]['is_live'] : TRUE;
  }

  return $features[$feature]['is_live'];
}

/**
 * Provides a test css class when environment is not prod.
 *
 * @param string $class
 *
 * @return string
 */
function loft_core_test_class(string $class): string {
  static $testing;
  if ($testing || (defined('DRUPAL_ENV_ROLE') && strpos(DRUPAL_ENV_ROLE,
        'prod') !== 0) || (!empty($_COOKIE['loft_core_testing']) && $_COOKIE['loft_core_testing'] === \Drupal::request()
        ->getClientIp())) {
    $testing = TRUE;

    return 't-' . $class;
  }
}

/**
 * Implements hook_js_settings_build().
 */
function loft_core_js_settings_build(array &$settings, \Drupal\Core\Asset\AttachedAssetsInterface $assets) {
  $settings['env'] = [
    'env' => DRUPAL_ENV,
    'role' => DRUPAL_ENV_ROLE,
    'prod' => DRUPAL_ENV_PROD,
    'staging' => DRUPAL_ENV_STAGING,
    'dev' => DRUPAL_ENV_DEV,
  ];
}

//
// ANYTHING ABOVE HERE HAS BEEN PORTED TO D8.
//
//
//
//
//
//
//
//

/**
 * Implements hook_preprocess_html().
 */
function loft_core_preprocess_html(&$vars) {
  $user = \Drupal::currentUser();
  $vars['loft_core_tracking'] = '';
  if (DRUPAL_ENV_ROLE === 'prod' && ($token = \Drupal::config('loft_core.settings')
      ->get('loft_core_trackjs_token'))) {

    // @link http://docs.trackjs.com/tracker/configuration
    $trackjs = [
      'config' => '',
      'metadata' => [],
    ];

    $trackjs['config']['token'] = $token;

    if (function_exists('web_package_get_version')) {
      $trackjs['config']['version'] = web_package_get_version();
    }

    // TrackJS allows you to track errors for multiple applications from the same account.
    // See the UI documentation for how to setup applications.
    $trackjs['config']['application'] = NULL;

    // If you have some identifiable string that represents a user or customer,
    //please include it.
    // In the TrackJS UI we allow you to group and filter by this value.
    $trackjs['config']['userId'] = \Drupal::currentUser()
      ->isAuthenticated() ? $user->uid : NULL;
    $trackjs['metadata']['username'] = \Drupal::currentUser()
      ->isAuthenticated() ? $user->name : NULL;

    // Similar to userId,
    //if you have a session guid or something you can set it here.
    // We allow you to search on this value in the UI.
    $trackjs['config']['sessionId'] = session_id();

    \Drupal::moduleHandler()->alter('loft_core_trackjs', $trackjs);

    $config = json_encode(array_filter($trackjs['config']));

    $meta = [];
    foreach (array_filter($trackjs['metadata']) as $key => $value) {
      $meta[] = 'trackJs.addMetadata("' . $key . '",
            "' . $value . '");';
    }
    $meta = implode(';',
      $meta);
    $vars['loft_core_tracking'] = <<<EOD
<!-- BEGIN TRACKJS -->
<script type="text/javascript">window._trackJs = {$config};</script>
<script type="text/javascript" src="https://cdn.trackjs.com/releases/current/tracker.js"></script>
<script type="text/javascript">{$meta};</script>
<!-- END TRACKJS -->        
EOD;
  }
}

/**
 * @FIXME
 * This implementation of hook_menu() cannot be automatically converted because
 * it contains logic (i.e., branching statements, function calls, object
 * instantiation, etc.) You will need to convert it manually. Sorry!
 *
 * For more information on how to convert hook_menu() to Drupal 8's new routing
 * and linking systems, see
 *   https://api.drupal.org/api/drupal/core%21includes%21menu.inc/group/menu/8
 */
function loft_core_menu() {
  $items[StaticContentStreamWrapper::URL_BASE] = [
    'type' => MENU_CALLBACK,
    'title' => 'Raw static content',
    'page callback' => 'loft_core_static_content_stream',
    'access arguments' => ['access raw static content'],
  ];

  return $items;
}


/**
 * Stream a static-content file.
 *
 * @param string $target
 *   The target static content file relative to the static content directory.
 */
function loft_core_static_content_stream($target) {
  $uri = 'static-content://' . $target;
  if (file_exists($uri)) {
    $headers = [];
    file_transfer($uri, $headers);
    drupal_access_denied();
  }
  else {
    drupal_not_found();
  }
  drupal_exit();
}

/**
 * @FIXME
 * hook_menu_alter() is gone in Drupal 8. You will have to port its
 * functionality manually. The are several mechanisms for this:
 *
 * To alter routes, you must implement a route subscriber class. An empty one
 * has been generated for you in src/Routing/RouteSubscriber.php.
 *
 * To alter menu link definitions, see hook_menu_links_discovered_alter(). An
 * empty implementation has been created at the end of this file.
 *
 * To alter local task definitions, see hook_menu_local_tasks_alter(). An
 * empty implementation has been created for you at the end of this file.
 *
 * To alter local actions, see hook_menu_local_actions_alter(). An
 * empty implementation has been created for you at the end of this file.
 *
 * Contextual links are altered during rendering only. See
 * hook_contextual_links_view_alter(). An empty implementation has been
 * created for you at the end of this file.
 *
 * @see https://www.drupal.org/node/2118147#alter
 * @see https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Menu%21menu.api.php/function/hook_menu_links_discovered_alter/8
 * @see https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Menu%21menu.api.php/function/hook_menu_local_tasks_alter/8
 * @see https://api.drupal.org/api/drupal/core%21lib%21Drupal%21Core%21Menu%21menu.api.php/function/hook_menu_local_actions_alter/8
 * @see https://api.drupal.org/api/drupal/core%21modules%21contextual%21contextual.api.php/function/hook_contextual_links_view_alter/8
 */

function loft_core_menu_alter(&$items) {
  if (\Drupal::config('loft_core.settings')->get('loft_core_node_redirects')) {
    $key = 'node/%node';
    if (isset($items[$key])) {
      $items[$key]['page callback'] = 'loft_core_node_page';
      $items[$key]['page arguments'][] = 'view';
    }
    $key = 'node/%node/view';
    if (isset($items[$key])) {
      $items[$key]['page callback'] = 'loft_core_node_page';
      $items[$key]['page arguments'][] = 'view';
    }
    $key = 'node/%node/edit';
    if (isset($items[$key])) {
      $items[$key]['page callback'] = 'loft_core_node_page';
      $items[$key]['page arguments'][] = 'edit';
    }
    $key = 'node/%node/delete';
    if (isset($items[$key])) {
      $items[$key]['page callback'] = 'loft_core_node_page';
      $items[$key]['page arguments'][] = 'delete';
    }
  }
}

/**
 * Menu callback: Displays a single node,
 * but checks for a redirect first.
 *
 * @param $node
 *   The node object.
 *
 * @return
 *   A page array suitable for use by drupal_render().
 *
 * @see node_menu()
 *
 *
 * // TODO Support node create?
 */
function loft_core_node_page($node, $op) {
  if (is_string($node)) {
    switch ($node) {
      case 'node_delete_confirm':
        $form_id = $node;
        $node = $op;
        $op = 'delete';
        break;
    }
  }

  //
  //
  // First check for a BUNDLE_TYPE_page...
  //
  if ($op === 'view') {
    $type = $node->type;
    $hook = 'loft_core_node_' . $type . '_page';
    if (($modules = \Drupal::moduleHandler()->getImplementations($hook))) {
      // We only take the last one.
      $callback = end($modules) . '_' . $hook;

      return $callback($node);
    }
  }

  //
  //
  // ... then look for a redirect.
  //
  if (($redirect = Redirect::getNodeMenuObjectRedirect($op))) {
    switch ($redirect['page callback']) {
      case 'drupal_not_found':
        return MENU_NOT_FOUND;
      case 'drupal_access_denied':
        return MENU_ACCESS_DENIED;
      default:
        call_user_func_array($redirect['page callback'],
          $redirect['page arguments']);
        break;
    }
  }

  // ... otherwise do the normal.
  switch ($op) {
    case 'delete':
      return \Drupal::formBuilder()->getForm($form_id,
        $node);
    default:
      $func = "node_page_{$op}";

      return $func($node);
  }
}


/**
 * Implements hook_element_info().
 */
function loft_core_element_info() {
  $types = [];
  $types['form_help'] = [
    '#weight' => -99,

    // string|array If array,
    //elements are separate paragraphs,
    //without <p> tag wrappers.
    '#message' => [],
    '#theme_wrappers' => [
      'form_help',
      'form_element',
    ],
  ];

  return $types;
}


function loft_core_theme($existing, $type, $theme, $path) {
  return [
    'form_help' => [
      'render element' => 'element',
    ],
  ];
}

/**
 * Implements hook_preprocess_form_help().
 */
function loft_core_preprocess_form_help(&$vars) {
  $element =& $vars['element'];

  // Wrap all elements of #message in p tags,
  //if array.
  if (is_array($element['#message'])) {
    array_walk($element['#message'],
      function (&$value) {
        if (strpos($value,
            '<p') !== 0
        ) {
          $value = '<p>' . $value . '</p>';
        }
      });
    $element['#message'] = implode('',
      $element['#message']);
  }
}


/**
 * Provides output for form help.
 *
 * DO NOT CALL DIRECTLY USE ['#type' => 'form_help',...] INSTEAD!
 *
 * @ingroup themeable
 */
function theme_form_help($vars) {
  $element = $vars['element'];
  $attributes = drupal_attributes($element['#attributes']);

  return '<blockquote' . $attributes . '>' . $element['#message'] . $element['#children'] . '</blockquote>';
}


/**
 * Invokes a hook on the default them if that implements it.
 *
 * @param $hook
 *   The name of the hook to invoke.
 * @param ...
 *   Arguments to pass to the hook.
 *
 * @return
 *   An array of return values of the hook implementations. If the theme returns
 *   arrays from it's implementation,
 * those are merged into one array
 *   recursively. Note: integer keys in arrays will be lost,
 * as the merge is
 *   done using array_merge_recursive().
 *
 * @see   drupal_alter()
 */
//function theme_invoke($hook)
//{
//    if (!($theme = variable_get('theme_default',
//null))) {
//        return;
//    }
//    $args = func_get_args();
//    // Remove $hook from the arguments.
//    unset($args[0]);
//    $return = array();
//
//    $function = $theme . '_' . $hook;
//    if (function_exists($function)) {
//        $result = call_user_func_array($function,
//$args);
//        if (isset($result) && is_array($result)) {
//            $return = array_merge_recursive($return,
//$result);
//        }
//        elseif (isset($result)) {
//            $return[] = $result;
//        }
//    }
//
//    return $return;
//}


/**
 * Adds commands echoing all drupal messages to trackjs
 *
 * Place this in an ajax response function where you have access to the
 * $commands array that is being build for the response.s
 *
 * @param array &$commands
 * @param array $severities Which drupal_get_messages() severity levels to
 *                          send.  Defaults to warning and error.
 *
 * @see _loft_core_trackjs_get_severities().
 */
function loft_core_trackjs_echo_drupal_messages(array &$commands, array $severities = [
  'warning',
  'error',
]
) {
  $groups = drupal_get_messages(NULL,
    FALSE);
  foreach ($groups as $level => $messages) {
    if (!in_array($level, $severities)) {
      continue;
    }
    switch ($level) {
      case 'warning':
        $trackjs_level = 'warn';
        break;
      case 'error':
        $trackjs_level = 'error';
        break;
      default:
        $trackjs_level = 'info';
        break;
    }
    foreach ($messages as $message) {
      $commands[] = loft_core_ajax_command_trackjs_console($trackjs_level,
        $message);
    }
  }
}


/**
 * Stash or unstash a user.
 *
 * This function:
 * - allows you to run some code as a different user inside of a callback
 * function, in which case you need simple call it once with $temporary_user
 * and $callback.
 * - allows you to set a temporary user for a time until you call this function
 * again.  Unless you call this function again, the temporary user will become
 * the logged in user, so USE WITH CARE.
 *
 * The stashed users will persist in the SESSION.
 *
 * @param null $temporary_user Leave null when unstashing a previously stashed
 *   user.
 * @param callable|NULL $callback
 */
function loft_core_user_stash($temporary_user = NULL, Callable $callback = NULL) {
  $user = \Drupal::currentUser();
  static $stashed = NULL;
  $needs_unstash = is_null($temporary_user);

  if ($temporary_user) {
    if ($stashed) {
      throw new \RuntimeException("A user has already been stashed; you must unstash before you try to stash another user.");
    }
    $needs_unstash = FALSE;
    $stashed = $user;
    $user = $temporary_user;

    // When callback is provided, we unstash post $callback.
    if ($callback) {
      $callback();
      $needs_unstash = TRUE;
    }
  }

  if ($stashed && $needs_unstash) {
    $user = $stashed;
    $stashed = NULL;
  }
}

/**
 * Implements hook_exit().
 */
function loft_core_exit() {

  // If the user has not been unstashed by now, we need to force it before drupal_session_commit() happens.
  loft_core_user_stash();

  // Remove some messages by hook.
  if (!empty($_SESSION['messages']) && ($masks = \Drupal::moduleHandler()
      ->invokeAll('loft_core_suppress_messages'))) {
    foreach (array_keys($masks) as $level) {
      if (isset($_SESSION['messages'][$level])) {
        foreach ($_SESSION['messages'][$level] as $key => $message) {
          foreach ($masks[$level] as $mask) {
            if (preg_match($mask, $message)) {
              unset($_SESSION['messages'][$level][$key]);
            }
          }
        }
      }
    };
  }
}

/**
 * Implements hook_mail_alter().
 *
 * Allow for a custom from address for registration emails.
 */
function loft_core_mail_alter(&$message) {
  if (($from = \Drupal::config('loft_core.settings')
    ->get('loft_core_mail_registration_from'))) {
    switch ($message['key']) {
      case 'register_admin_created':
      case 'register_no_approval_required':
      case 'register_pending_approval':
        $message['from'] = $from;
        foreach (['Return-Path', 'Sender', 'From'] as $key) {
          $message['headers'][$key] = $from;
        }
        break;
    }
  }
}

/**
 * Implements hook_preprocess_status_report().
 */
function loft_core_preprocess_status_report(&$vars) {
  $unset = NULL;
  array_walk($vars['requirements'], function (&$item, $key) use (&$unset) {
    if ($item['title'] !== 'Update notifications') {
      return;
    }

    //
    //
    // ITLS wants updates module disabled on prod since I monitor client updates using another system. And we don't
    // want clients to think there is a problem so we hide the default warning when update is disabled.
    //
    // @FIXME
    // // @FIXME
    // // This looks like another module's variable. You'll need to rewrite this call
    // // to ensure that it uses the correct configuration object.
    // $allows_ftp_updates = variable_get('allow_authorize_operations', TRUE);

    if ($allows_ftp_updates) {
      $item = [
        'title' => '$allow_authorize_operations',
        'description' => t('If you are using GIT you should add this line to <em>settings.php</em>: <code>$conf[\'allow_authorize_operations\'] = FALSE;</code>'),
        'value' => 'true',
        'severity' => REQUIREMENT_ERROR,
      ];
    }
    elseif (DRUPAL_ENV_ROLE === 'prod' && $item['value'] === t('Enabled')) {
      $item['severity'] = REQUIREMENT_WARNING;
      $item['description'] = t('Update module should not be enabled on production as updates are handled by ITLS.');
    }
    elseif (isset($item['severity']) && $item['severity'] === REQUIREMENT_WARNING) {
      $unset = $key;
    }
  });

  if ($unset) {
    unset($vars['requirements'][$unset]);
  }
}


/**
 * Load (shadow) entities.
 *
 * For a node this returns an object with these properties: nid, vid and type.
 * These are faster to load and can be used in some contexts as needed just for
 * reference, like when using entity_extract_ids() or EntityFieldQuery.
 *
 * @param string $entity_type
 * @param array $entity_ids
 *
 * @return array An array of shadow entity objects.  Each item has the key
 *   #loaded set to false so you can check if this is a shadow entity.
 */
function loft_core_shadow_entity_load($entity_type, array $entity_ids) {
  $query = new \EntityFieldQuery();
  $entities = array_map(function ($bundles) {
    foreach ($bundles as &$bundle) {
      $bundle->loft_core_shadow = TRUE;
    }

    return $bundles;
  }, $query
    ->entityCondition('entity_type', $entity_type)
    ->entityCondition('entity_id', $entity_ids)
    ->execute());

  return $entities[$entity_type];
}

/**
 * Implements hook_stream_wrappers().
 */
function loft_core_stream_wrappers() {

  // This is here to address an issue of missing class when using drush updb.
  if (!class_exists('\Drupal\loft_core\StaticContentStreamWrapper')) {
    module_load_include('php', 'loft_core', 'src/Drupal/loft_core/StaticContentStreamWrapper');
  }

  $wrappers = [
    'static-content' => [
      'name' => t('Static content'),
      'class' => '\Drupal\loft_core\StaticContentStreamWrapper',
      'description' => t("Content that should not be exposed to the CMS, but included in the final output."),
    ],
  ];

  return $wrappers;
}

/**
 * Implements hook_menu_links_discovered_alter().
 */
function loft_core_menu_links_discovered_alter(array &$links) {
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function loft_core_menu_local_tasks_alter(array &$data, $route_name) {
}

/**
 * Implements hook_menu_local_actions_alter().
 */
function loft_core_menu_local_actions_alter(array &$local_actions) {
}

/**
 * Implements hook_contextual_links_view_alter().
 */
function loft_core_contextual_links_view_alter(array &$element, array $items) {
}
