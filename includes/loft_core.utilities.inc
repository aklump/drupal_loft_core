<?php

/**
 * @file
 * Utility functions.
 */

use AKlump\Bem\Fluent\Bem;
use Drupal\Core\Template\Attribute;
use Drupal\Core\Url;


/**
 * Builds a list of all token-like patterns that appear in the text.
 *
 * @param string $text
 *   The text to be scanned for possible tokens.  We are expecting tokens that
 *   look like this: "{{ type:name }}" and {{ type:name:sub:thing }}, the colon
 *   may be replaced with a ., e.g. "{{ type.name }}".  That is colon and dot
 *   are interchangeable.
 *
 * @return array
 *   An associative array of discovered tokens, grouped by type.
 */
function loft_core_twiglike_token_scan(string $text): array {
  // Matches tokens with the following pattern: [$type:$name]
  // $type and $name may not contain  [ ] characters.
  // $type may not contain : or whitespace characters, but $name may.
  preg_match_all('/
    \{\{\s*([^.]*?)(?:\.(.*?))?\s*\}\}
    /x', $text, $matches);

  $types = $matches[1];
  $tokens = $matches[2];

  // Iterate through the matches, building an associative array containing
  // $tokens grouped by $types, pointing to the version of the token found in
  // the source text. For example, $results['node']['title'] = '[node:title]'.
  $results = [];
  for ($i = 0; $i < count($tokens); $i++) {
    $drupal = $drupal = '[' . trim($matches[1][$i] . ':' . $matches[2][$i], ':') . ']';
    $results['tokens'][$types[$i]][$tokens[$i]] = $drupal;
    $results['map'][$drupal] = $matches[0][$i];
  }

  return $results;
}

/**
 * This function replaces twig-like tokens with values in $data
 *
 * Tokens in $text must be {{ type:name }} or {{ type:some:kind:of:name }}
 * format.
 *
 * This is not for use with the token module.
 *
 * @param string $text
 *   Should contain something like {{ sender.name }}
 * @param array $data Should be like ['sender'=>['name'=>'Paul']]
 *
 * @return string
 *
 * @fixme Must port to d8, not working.
 * @see loft_core_twiglike_token_replace for Token module usage.
 *
 */
function loft_core_twiglike_replace($text, array $data = []) {
  $token_data = loft_core_twiglike_token_scan($text);
  foreach ($token_data['tokens'] as $type => $items) {
    foreach ($items as $key => $drupal) {
      $replace = $data[$type][$key] ?? '';
      if ($replace) {
        $text = str_replace($token_data['map'][$drupal], $replace, $text);
      }
    }
  }

  return $text;
}

/**
 * Replace twig like tokens in a chunk of text.
 *
 * Only use this if your tokens are generated by hook_tokens().
 *
 * @param string $text
 * @param array $data
 * @param array $options
 *
 * @return mixed
 *
 * @see token_replace().
 *
 * @fixme Must port to d8, not working.
 */
function loft_core_twiglike_token_replace($text, array $data = [], array $options = []) {
  list($tokens, $values) = loft_core_twiglike_tokens_get($text, $data, $options);

  return $tokens ? str_replace($tokens, $values, $text) : $text;
}

/**
 * Get the tokens and values for a chunk of text.
 *
 * @param string $text
 * @param array $data
 * @param array $options
 *
 * @return array
 *
 * @code
 *   list($tokens, $values) = loft_core_twiglike_token_get(...
 * @endcode
 *
 * @fixme Must port to d8, not working.
 */
function loft_core_twiglike_tokens_get(string $text, array $data = [], array $options = []) {
  $token_data = loft_core_twiglike_token_scan($text);
  if (empty($token_data)) {
    return [[], []];
  }
  $text_tokens = $token_data['tokens'];

  $replacements = [];
  foreach ($text_tokens as $type => $tokens) {
    $replacements += \Drupal::token()
      ->generate($type, $tokens, $data, $options);
    if (!empty($options['clear'])) {
      $replacements += array_fill_keys($tokens, '');
    }
  }

  // Optionally alter the list of replacement values.
  if (!empty($options['callback']) && function_exists($options['callback'])) {
    $function = $options['callback'];
    $function($replacements, $data, $options);
  }

  $tokens = [];
  foreach ($replacements as $find => $replace) {
    $tokens[$token_data['map'][$find]] = $replace;
  }
  $values = array_map(function ($item) {
    return strval($item);
  }, array_values($tokens));
  $tokens = array_keys($tokens);

  return [$tokens, $values];

}


/**
 * Returns the unaliased relative path to a location on this site.
 *
 * For www.mysite.com if $path = 'http://www.mysite.com/node/21' then
 * '/node/21'
 * will be returned.  You may want to add something like this to your website
 * to alter the default functionality, which is often sufficient.
 *
 * @code
 *  $config['loft_core.settings']['smart_url_regex'] =
 *   '/mysite.(?:org|loft)$/i';
 * @endcode
 *
 * @param string $absolute_aliases_path
 *   The path to simplify, if possible.
 * @param array $options
 *   These are the same as for url().  You might want to use alias = true.
 *
 * @return string
 *   At the very least $absolute_aliases_path will be passed through untouched.
 *    If the path is understood to be part of this site, then it's unaliased,
 *   relative value will be returned.
 */
function loft_core_smart_url(string $absolute_aliases_path, array $options = []): string {
  $parts = parse_url($absolute_aliases_path);
  if (!empty($parts['host'])) {
    if (!($regex = \Drupal::config('loft_core.settings')
      ->get('smart_url_regex'))) {
      $frontpage = Url::fromRoute('<front>', [], ['absolute' => TRUE])
        ->toString();
      $regex = '/' . preg_quote(parse_url($frontpage, PHP_URL_HOST)) . '$/i';
    }
    if (preg_match($regex, $parts['host'])) {
      $absolute_aliases_path = rtrim($parts['path'], '/');
      if (($system_path = \Drupal::service('path.alias_manager')
        ->getPathByAlias($absolute_aliases_path))) {
        $absolute_aliases_path = Url::fromUserInput($system_path, $options)
          ->toString();
      }
    }
  }

  return $absolute_aliases_path;
}

/**
 * Return an array of taxonomy items filtered to unique.
 *
 * @param array $items
 *
 * @return array
 *
 * @todo Port to D8 if needed.
 */
function loft_core_taxonomy_unique(array $items) {
  $index = [];

  return array_filter($items, function ($item) use (&$index) {
    $item = (array) $item;
    $allow = !in_array($item['tid'], $index);
    $index[] = $item['tid'];

    return $allow;
  });
}

/**
 * Return a function to use for SMACSS classes
 *
 * @code
 * $cl = loft_core_cl('my-base');
 * $class = $cl('title');
 *
 * $class === 'my-base__title';
 * @endcode
 *
 * @param string $base The BEM module name
 * @param bool $pass_through Set this to true and $base will not be filtered
 *   for invalid chars.  Set it to false and spaces and underscores will be
 *   converted to hyphens.
 *
 * @return callable
 *
 * @deprecated See https://packagist.org/packages/aklump/bem for replacement.
 */
function loft_core_cl($base, $pass_through = FALSE) {
  if (!$pass_through) {
    $base = preg_replace('/[_ ]/', '-', $base);
  }
  $bem = new Bem($base);

  return function ($value = '', $is_element = TRUE) use ($bem) {
    $values = is_array($value) ? $value : [$value];
    $classes = [];
    foreach ($values as $value) {
      if (!$value) {
        $classes[] = $bem->block()->toString();
      }
      elseif ($is_element) {
        $classes[] = $bem->element($value)->toString();
      }
      else {
        $classes[] = $bem->block()->modifier($value)->toString();
      }
    }

    return implode(' ', $classes);
  };
}

/**
 * Callback for #post_render to add a cache-busting token to image derivatives.
 *
 * This example shows how to add a cache buster to a certain node image field
 * when the user is logged in to the website.
 *
 * @code
 *   function HOOK_node_view_alter(&$build)
 *   {
 *       if (!empty($build['product:field_image']) && user_is_logged_in()) {
 *           $build['product:field_image']['#post_render'][] =
 *           'loft_core_image_src_itok_cache_buster';
 *       }
 *   }
 * @endcode
 *
 * @param string $html Expecting to contain ?itok=123"
 * @param array $build Expecting to find:
 *                      - #object->changed
 *
 * @return string The modified html
 */
function loft_core_image_src_itok_cache_buster($html, $build) {
  $user = \Drupal::currentUser();
  $buster = [
    0 => \Drupal::config('loft_core.settings')
      ->get('loft_core_cache_bust_token'),
    1 => NULL,
  ];
  if ((!empty($build['#object']->changed))) {
    $buster[1] = $build['#object']->changed;
  }
  elseif ((!empty($user->access))) {
    $buster[1] = $user->access;
  }
  else {
    $buster[1] = time();
  }
  $regex = '/' . preg_quote(IMAGE_DERIVATIVE_TOKEN) . '[^"]+/';
  $html = preg_replace($regex,
    '$0&' . implode('=',
      $buster),
    $html);

  return $html;
}

/**
 * Return a build array for a div, optionally wrapping another build array.
 *
 * @param string|array $class One or more classes to add to the div.
 * @param array $element Optional, the build array which you will wrap
 *                              with the div.
 *
 * @return array The wrapped element.
 * The wrapped element.
 */
function div($class, array $element = []): array {
  $attributes = new Attribute(['class' => $class]);
  $div = [
    '#prefix' => '<div' . $attributes . '>',
    '#suffix' => "</div>",
    0 => $element,
  ];

  return $div;
}

/**
 * Return $element with all children keys turned into property keys (prepend
 * '#')
 *
 * @param $element
 *
 * @return array
 */
function loft_core_element_children_to_properties($element) {
  return array_combine(array_map(function ($item) {
    return '#' . ltrim($item, '#');
  }, array_keys($element)), array_values($element));
}

/**
 * Remove all null values from an array.
 *
 * @param $array
 *
 * @return array
 */
function null_filter($array) {
  return array_filter($array, function ($item) {
    return !is_null($item);
  });
}

/**
 * Make a css safe class or id
 *
 * @param string or array $input
 *                    The string will be made css safe; array values will be
 *                    made css safe
 * @param bool $flatten
 *                    Optional.  Set to TRUE to flatten arrays into space
 *                    separated strings
 *
 * @return string or array
 */
function loft_core_css_safe($input, $flatten = FALSE) {
  if (is_array($input)) {
    $function = __FUNCTION__;
    foreach ($input as $key => $value) {
      $input[$key] = $function($value);
    }

    return $flatten ? trim(implode(' ', $input)) : $input;
  }
  elseif ($input == ($string = strval($input))) {
    $input = trim(strtolower(preg_replace('/[\W_]{1}/', '-', $string)), '-');
    if (preg_match('/^(\d)(.*)/', $input, $found)) {
      $word = [
        'zero',
        'one',
        'two',
        'three',
        'four',
        'five',
        'six',
        'seven',
        'eight',
        'nine',
      ];
      $input = $word[$found[1]] . $found[2];
    }
  }

  return $input;
}

/**
 * Return the maximum weight in a render array,
 * top level only.
 *
 * @param array $render_array
 *
 * @return int
 */
function loft_core_max_weight(array $render_array): int {
  $max = 0;
  array_walk($render_array, function ($value) use (&$max) {
    if (is_array($value)) {
      $max = max($max, $value['#weight'] ?? 0);
    }
  });

  return $max;
}

/**
 * Return the minimum weight in a render array,
 * top level only.
 *
 * @param $render_array
 *
 * @return int
 */
function loft_core_min_weight($render_array) {
  $min = 0;
  array_walk($render_array, function ($value) use (&$min) {
    if (is_array($value)) {
      $min = min($min, $value['#weight'] ?? 0);
    }
  });

  return $min;
}

/**
 * Return callbacks to use for generating BEM element and modifier classes.
 *
 * @param string $block
 *   The block name.
 *
 * @return array
 *   - 0 Callback taking element and returning the full BEM element class.
 *   - 1 Callback taking modifier and returning the full BEM modifier class.
 * @code
 *   list($bem, $bem_mod) = loft_core_bem('resource-hero');
 * @endcode
 *
 * @deprecated See https://packagist.org/packages/aklump/bem for replacement.
 */
function loft_core_bem(string $block): array {
  $bem = new Bem($block);
  if ($bem->block()->toString() !== $block) {
    throw new \InvalidArgumentException("This BEM block name contains invalid characters: \"$block\".");
  }

  return [
    function ($element = '') use ($bem) {
      return strval($element ? $bem->element($element) : $bem->block());
    },
    function ($modifier = '') use ($bem) {
      return strval($modifier ? $bem->block()->modifier($modifier) : $bem->block());
    },
  ];
}
