<?php

/**
 * @file
 * Functions that have to do with installation and updates.
 */

/**
 * Create an archive of entities.
 *
 * This is designed to be used as the sole contents of a hook_update_n
 * implementation.
 *
 * @param string $destination_dir
 *   The destination direction for the archive, e.g. 'temporary://foo/bar'.
 * @param string $update_message
 *   This is the docblock comment for the hook_update_n function.
 * @param string $sql
 *   The SQL that generates the dataset to export.
 * @param string $filename
 *   The filename of the data files that are exported.
 * @param array $image_keys_map
 *   An associative array representing a map of query keys that point to the
 *   filename and the file URI.  Each element has two values:
 *   - 0 The key from the query that holds the image filename.
 *   - 1 The key from teh query that holds the image URI.
 * @param callable|null $value_transform_callback
 *   A callable that receives ($key, $value) and must return true if the
 *   key/value should be added to the export.  $value should be received by
 *   reference and mutated as desired.
 *
 * @return string
 *   The message of work done.
 *
 * @throws \DrupalUpdateException
 */
function loft_core_archive_entities_update(
  $destination_dir,
  $update_message,
  $sql,
  $filename,
  array $image_keys_map = [],
  callable $value_transform_callback = NULL
) {
  loft_data_grids_boot();
  $output = [];
  try {
    $query = db_query($sql);
    $query->execute();
    file_prepare_directory($destination_dir, FILE_CREATE_DIRECTORY);
    $header = NULL;

    $data = new \AKlump\LoftDataGrids\ExportData();
    while ($record = $query->fetchAssoc()) {
      foreach ($record as $key => $value) {
        $add_to_export = TRUE;

        if (!is_callable($value_transform_callback) || ($value_transform_callback($key, $value))) {
          $add_to_export = TRUE;
        }

        // Archive the images.
        foreach ($image_keys_map as $image_map) {
          if ($key === $image_map[1]) {
            $add_to_export = FALSE;
            $image_dir = "$destination_dir/images/";
            file_prepare_directory($image_dir, FILE_CREATE_DIRECTORY);
            $destination = $image_dir . '/' . $record[$image_map[0]];
            if (!file_exists($destination)) {
              if (!file_unmanaged_copy($value, $destination, FILE_EXISTS_REPLACE)) {
                throw new \RuntimeException("Could not copy: $value.");
              }
            }
          }
        }

        if ($add_to_export) {
          $data->add($key, $value);
        }
      }
      $data->next();
    }

    $exporter = new \AKlump\LoftDataGrids\CSVExporter($data, $filename);
    $path = $exporter->saveFile($destination_dir);
    if (!file_exists($path)) {
      throw new \RuntimeException("Could not save: $destination_dir/$filename");
    }

    $exporter = new \AKlump\LoftDataGrids\JSONExporter($data, $filename);
    $path = $exporter->saveFile($destination_dir);
    if (!file_exists($path)) {
      throw new \RuntimeException("Could not save: $destination_dir/$filename");
    }

    $output[] = 'Please move your archive from: ' . $destination_dir . ' to a safe place.';

    return implode(PHP_EOL, $output);
  }
  catch (Exception $e) {
    throw new DrupalUpdateException('FAILED: ' . $update_message . ': ' . $e->getMessage());
  }
}
