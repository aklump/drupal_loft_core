<?php
/**
 * @file
 * Base file for the loft_core_users module.
 *
 * @defgroup loft_core_users Loft Core Users
 * @{
 */

/**
 * This account was trapped as a robot.
 */
define('LOFT_CORE_USERS_STATUS_ROBOT', 2);

/**
 * This account was trapped by the honepot module.
 */
define('LOFT_CORE_USERS_STATUS_HONEYBEAR', 3);

/**
 * This account was trapped by the honepot module then converted to SPAMMY
 */
define('LOFT_CORE_USERS_STATUS_HONEYBEAR_MADE_SPAMMY', 34);

/**
 * For one reason or another this account appears spammy.
 */
define('LOFT_CORE_USERS_STATUS_SPAMMY', 4);

/**
 * @var LOFT_CORE_USERS_DOMAIN_WHITELIST
 *
 * CSV list of domains to whitelist that cannot will not be blocked, regardless
 * of the spam levels associated with their users.
 */
define('LOFT_CORE_USERS_DOMAIN_WHITELIST', 'gmail.com,yahoo.com');

/**
 * Return all status codes that should block a user from the site.
 *
 * @return array
 */
function loft_core_users_get_blocking_statuses()
{
    return array(
        LOFT_CORE_USERS_STATUS_ROBOT,
        LOFT_CORE_USERS_STATUS_SPAMMY,
        LOFT_CORE_USERS_STATUS_HONEYBEAR_MADE_SPAMMY,
    );
}

/**
 * Return an array of domains that should not be blocked.
 *
 * @return mixed|null
 */
function loft_core_users_get_domain_whitelist()
{
    return variable_get('loft_core_users_domain_whitelist', explode(',', LOFT_CORE_USERS_DOMAIN_WHITELIST));
}

/**
 * Implements hook_module_implements_alter().
 */
function loft_core_users_module_implements_alter(&$implementations, $hook)
{
    if ($hook == 'user_restrictions_alter') {
        // user_restrictions module overwrites our $error unless we call it first.
        $group = $implementations['loft_core_users'];
        unset($implementations['loft_core_users']);
        $implementations['loft_core_users'] = $group;
    }
}

/**
 * Return the domain of an email address.
 *
 * @param string $email
 *
 * @return string
 */
function _loft_core_users_get_email_domain($email)
{
    $domain = preg_replace('/^.+@/', '', $email);
    $domain = explode('.', $domain);

    return implode('.', array_slice($domain, -2));
}

/**
 * Block an authenticated  user with (special) status.
 *
 * @param int $status
 * @param int $uid
 *
 * @see LOFT_CORE_USERS_STATUS_*
 */
function loft_core_users_block_user($status, $uid)
{
    if ($status > 1) {
        loft_core_users_set_user_status($status, $uid);
    }
    $account = (object) [
        'uid' => $uid,
    ];
    if ($status != 1) {
        user_block_user_action($account);
    }
}

/**
 * Return current loft user status.
 *
 * If providiing $uid, that is all that is used.  Otherwise provide $uid, $mail
 * and/or $ip.
 *
 * @param int    $uid
 * @param string $domain The domain (email is fine, but will be converted to
 *                       domain).
 * @param string $ip
 *
 * @return int|null
 */
function loft_core_users_get_user_status($uid = null, $domain = null, $ip = null)
{
    $status = null;
    if ($uid !== null || $domain !== null || $ip !== null) {
        $query = db_select('loft_core_users', 'lu')
            ->fields('lu', array('status'));
        if ($uid) {
            $query->condition('uid', $uid);
        }
        else {
            $query->condition('uid', $uid);
            if (!is_null($domain)) {
                $domain = _loft_core_users_get_email_domain($domain);
                $query->condition('domain', $domain);
            }
            if (!is_null($ip)) {
                $query->condition('ip', $ip);
            }
        }

        try {
            $result = $query->execute();
            $status = $result->fetchField();
        } catch (Exception $e) {
            watchdog_exception('loft_core_users', $e);
        }
    }

    return is_numeric($status) ? intval($status) : null;
}

/**
 * Set the Loft Core status of a user.
 *
 * You MUST update users.status separate; this module does not handle that.
 *
 * @param int               $status
 * @param int               $uid
 * @param string            $mail email or domain.
 * @param null|stringstring $ip
 *
 * @internal param $account
 * @see      loft_core_users_block_user().
 */
function loft_core_users_set_user_status($status, $uid, $mail, $ip = null)
{
    $meta = [
        'uid' => $uid,
        'uid_init' => $uid,
        'status' => $status,
        'domain' => _loft_core_users_get_email_domain($mail),
        'ip' => $ip,
    ];
    $meta = array_filter($meta, function ($value) {
        return !is_null($value);
    });

    //
    //
    // Authenticated users
    //
    if ($uid) {
        $query = db_select('loft_core_users', 'lu')
            ->fields('lu', ['uid'])
            ->condition('uid', $uid);
        $exists = $query->execute()->fetchField();
        $primary_key = 'uid';
    }

    //
    //
    // Anonymous users
    //
    else {
        $exists = db_select('loft_core_users', 'lu')
            ->condition('uid', 0)
            ->condition('domain', $meta['domain'])
            ->condition('ip', $meta['ip'])
            ->countQuery()->execute()->fetchField();
        $primary_key = ['uid', 'domain', 'ip'];
    }
    if ($exists) {
        unset($meta['uid_init']);
        drupal_write_record('loft_core_users', $meta, $primary_key);
    }
    else {
        drupal_write_record('loft_core_users', $meta);
    }
}

/**
 * This can be used as an menu page callback to trap robots.
 *
 * The basic idea is that if a visitor hits an url that they shouldn't then by
 * doing so they are exposing their nefarious intentions.  Their account will
 * immediately be blocked and they are logged out.  Watchdog messages will show
 * this has happened.
 *
 * To implement this feature, you need to modify a menu page callback.  And set
 * this function as the page callback.  In this next example we are going to
 * modify a node/add/user-collection to trap users.
 *
 * @code
 *   if (isset($items['node/add/user-collection'])) {
 *     array_unshift($items['node/add/user-collection']['page arguments'],
 *     $items['node/add/user-collection']['page callback']);
 *     $items['node/add/user-collection']['page callback'] =
 *     'loft_core_users_robotrap_page_callback';
 *   }
 * @endcode
 *
 * You MUST implement hook_loft_core_users_robotrap_access().
 * You MAY implement hook_loft_core_users_robotrap_goto_alter().
 */
function loft_core_users_robotrap_page_callback()
{
    global $user;
    $args = func_get_args();
    $callback = array_shift($args);
    $context = [
        'parent' => __FUNCTION__,
        'account' => $user,
        'page callback' => $callback,
        'page arguments' => $args,
    ];
    $access = module_invoke_all('loft_core_users_robotrap_access', $context);
    $access = end($access);
    if (!$access) {
        watchdog('loft_core_users', 'Robotrapped user %name.', ['%name' => $user->name]);
        loft_core_users_block_user(LOFT_CORE_USERS_STATUS_ROBOT, $user->uid);
        //        loft_core_users_block_user(LOFT_CORE_USERS_STATUS_ROBOT, $user->uid, $user->mail, ip_address());
        module_load_include('inc', 'user', 'user.pages');
        user_logout_current_user();
        drupal_set_message(t('You have visited a forbidden url; your account has been locked for review.  Please contact us using the form below to unlock your account.', ['!url' => url('contact', ['query' => ['cid' => 6]])]), 'warning', false);
        $path = module_exists('contact') ? 'contact' : '<front>';
        unset($_GET['destination']);
        $options = [];
        $context['parent'] = __FUNCTION__;
        drupal_alter('loft_core_users_robotrap_goto', $path, $options, $context);
        drupal_goto($path, $options);

        return false;
    }
    else {
        return call_user_func_array($callback, $args);
    }
}

/**
 * Implements hook_user_restrictions_alter().
 */
function loft_core_users_user_restrictions_alter(&$denied, &$error, &$context)
{
    //
    //
    // Restrict any email address whose domain matches that of an already robo-trapped user.
    //
    if ($context['type'] === 'mail') {

        // Check if the domain has been trapped.
        $domain = _loft_core_users_get_email_domain($context['form_state']['values']['mail']);

        // Check if this domain is whitelisted.
        if (!in_array($domain, loft_core_users_get_domain_whitelist())) {

            $query = db_select('loft_core_users', 'lu')
                ->fields('lu', ['uid', 'domain'])
                ->condition('status', loft_core_users_get_blocking_statuses(), 'IN')
                ->condition('domain', $domain);

            // If trapped, leverage user_restrictions module to block by email address.
            if ($is_suspicious = $query->execute()->fetchAllAssoc('uid')) {
                watchdog('loft_core_users', 'Denied user from @%domain.', ['%domain' => $domain]);
                $context['mask'] = '*' . $domain;
                $denied = true;
                $error['field'] = 'mail';
                $contact = 'contact us';

                // With the contact module enabled we give an easy way for mistakes to get corrected.
                if (module_exists('contact')) {
                    unset($_GET['destination']);
                    $options = [];
                    $path = 'contact';
                    $contact = '<a href="!url">contact us</a>';
                    $context['parent'] = __FUNCTION__;
                    drupal_alter('loft_core_users_robotrap_goto', $path, $options, $context);
                }
                $error['message'] = t('Your email address is associated with a suspicious domain (%domain); please ' . $contact . ' if this is in error.', [
                    '%domain' => $domain,
                    '!url' => url($path, $options),
                ]);
            }
        }
    }
}

/**
 * Implements hook_honeypot_reject().
 *
 * Make a note of this email address/user as a honeybear.
 */
function loft_core_users_honeypot_reject($form_id, $uid, $type)
{
    $g = data_api();
    if (($mail = $g->get($_POST, 'mail'))) {
        $domain = _loft_core_users_get_email_domain($mail);
        $default = explode(',', LOFT_CORE_USERS_DOMAIN_WHITELIST);
        $may_block = !in_array($domain, variable_get('loft_core_users_domain_whitelist', $default));
        if ($may_block) {
            loft_core_users_set_user_status(LOFT_CORE_USERS_STATUS_HONEYBEAR, $uid, $mail, ip_address());
        }
    }
}

/**
 * Implements hook_action_info().
 */
function loft_core_action_info()
{
    return array(
        'loft_core_users_block_spammy_user_action' => array(
            'label' => t('Block SPAMMY user'),
            'type' => 'user',
            'configurable' => false,
            'triggers' => array('any'),
        ),
    );
}

/**
 * Action to mark a user as spammy.
 *
 * @param       $entity
 * @param array $context
 */
function loft_core_users_block_spammy_user_action(&$entity, $context = array())
{
    // First priority: If there is a $entity->uid, block that user.
    // This is most likely a user object or the author if a node or comment.
    if (isset($entity->uid)) {
        $uid = $entity->uid;
    }
    elseif (isset($context['uid'])) {
        $uid = $context['uid'];
    }
    // If neither of those are valid, then block the current user.
    else {
        $uid = $GLOBALS['user']->uid;
    }
    $current_status = loft_core_users_get_user_status($uid);
    $new_status = $current_status === LOFT_CORE_USERS_STATUS_HONEYBEAR ? LOFT_CORE_USERS_STATUS_HONEYBEAR_MADE_SPAMMY : LOFT_CORE_USERS_STATUS_SPAMMY;
    loft_core_users_block_user($new_status, $uid);
}

/**
 * Implements hook_form_user_registration_alter().
 */
function loft_core_users_form_user_register_form_alter(&$form, &$form_state)
{
    // If an admin is creating the user, we would not want to capture the IP because the ip would not be tracking the user, but the admin.  Therefor we don't even capture anything... as there is really no point, and to save database.
    if (!path_is_admin(current_path())) {
        $form['#submit'][] = 'loft_core_users_user_register_form_submit';
    }
}

/**
 * Submit handler to record the ip of a new user.
 *
 * @param $form
 * @param $form_state
 */
function loft_core_users_user_register_form_submit($form, $form_state)
{
    // When a new account is submitted, capture the IP.
    $account = $form_state['user'];
    loft_core_users_set_user_status($account->status, $account->uid, $account->init, ip_address());
}

/**
 * Implements hook_menu().
 */
function loft_core_users_menu()
{
    $items['admin/config/people/loft-core-users'] = array(
        'title' => 'Loft Core',
        'page callback' => 'drupal_get_form',
        'page arguments' => array('loft_core_users_settings_form'),
        'access arguments' => array('loft_core_users:administer'),
        'type' => MENU_NORMAL_ITEM,
        'file' => 'loft_core.admin.inc',
    );

    return $items;
}

/**
 * Implements hook_permission().
 */
function loft_core_users_permission()
{
    return array(
        'loft_core_users:administer' => array(
            'title' => t('Administer Loft Core Users'),
            'description' => t('Perform administration tasks for Loft Core Users.'),
            'restrict access' => true,
        ),
    );
}

/**
 * Implements hook_views_api().
 */
function loft_core_users_views_api()
{
    return array(
        'api' => 3,
        'path' => drupal_get_path('module', 'loft_core_users') . '/includes/views',
    );
}


/**
 * Implements hook_user_delete().
 */
function loft_core_users_user_delete($account)
{
    // When the user is deleted, change the UID to 0
    db_update('loft_core_users')
        ->fields(array(
                'uid' => 0,
                'uid_init' => $account->uid,
            )
        )
        ->condition('uid', $account->uid)
        ->execute();
}



/**
 * Inform the base system and the Field API about one or more entity types.
 *
 * Inform the system about one or more entity types (i.e., object types that
 * can be loaded via entity_load() and, optionally, to which fields can be
 * attached).
 *
 * @return
 *   An array whose keys are entity type names and whose values identify
 *   properties of those types that the system needs to know about:
 *   - label: The human-readable name of the type.
 *   - controller class: The name of the class that is used to load the objects.
 *     The class has to implement the DrupalEntityControllerInterface interface.
 *     Leave blank to use the DrupalDefaultEntityController implementation.
 *   - base table: (used by DrupalDefaultEntityController) The name of the
 *     entity type's base table.
 *   - revision table: The name of the entity type's revision table (if any).
 *   - static cache: (used by DrupalDefaultEntityController) FALSE to disable
 *     static caching of entities during a page request. Defaults to TRUE.
 *   - field cache: (used by Field API loading and saving of field data) FALSE
 *     to disable Field API's persistent cache of field data. Only recommended
 *     if a higher level persistent cache is available for the entity type.
 *     Defaults to TRUE.
 *   - load hook: The name of the hook which should be invoked by
 *     DrupalDefaultEntityController:attachLoad(), for example 'node_load'.
 *   - uri callback: The name of an implementation of
 *     callback_entity_info_uri().
 *   - label callback: (optional) The name of an implementation of
 *     callback_entity_info_label(), which returns the label of the entity. The
 *     entity label is the main string associated with an entity; for example,
 *     the title of a node or the subject of a comment. If there is an entity
 *     object property that defines the label, then using the 'label' element of
 *     the 'entity keys' return value component suffices to provide this
 *     information (see below). Alternatively, specifying this callback allows
 *     more complex logic to determine the label of an entity. See also the
 *     entity_label() function, which implements this logic.
 *   - language callback: (optional) The name of an implementation of
 *     callback_entity_info_language(). In most situations, when needing to
 *     determine this value, inspecting a property named after the 'language'
 *     element of the 'entity keys' should be enough. The language callback is
 *     meant to be used primarily for temporary alterations of the property
 *     value: entity-defining modules are encouraged to always define a
 *     language property, instead of using the callback as main entity language
 *     source. In fact not having a language property defined is likely to
 *     prevent an entity from being queried by language. Moreover, given that
 *     entity_language() is not necessarily used everywhere it would be
 *     appropriate, modules implementing the language callback should be aware
 *     that this might not be always called.
 *   - fieldable: Set to TRUE if you want your entity type to accept fields
 *     being attached to it.
 *   - translation: An associative array of modules registered as field
 *     translation handlers. Array keys are the module names, array values
 *     can be any data structure the module uses to provide field translation.
 *     Any empty value disallows the module to appear as a translation handler.
 *   - entity keys: (optional) An array describing how the Field API can extract
 *     the information it needs from the objects of the type. Elements:
 *     - id: The name of the property that contains the primary id of the
 *       entity. Every entity object passed to the Field API must have this
 *       property and its value must be numeric.
 *     - revision: The name of the property that contains the revision id of
 *       the entity. The Field API assumes that all revision ids are unique
 *       across all entities of a type. This entry can be omitted if the
 *       entities of this type are not versionable. Defaults to an empty string.
 *     - bundle: The name of the property that contains the bundle name for the
 *       entity. The bundle name defines which set of fields are attached to
 *       the entity (e.g. what nodes call "content type"). This entry can be
 *       omitted if this entity type exposes a single bundle (all entities have
 *       the same collection of fields). The name of this single bundle will be
 *       the same as the entity type. Defaults to an empty string.
 *     - label: The name of the property that contains the entity label. For
 *       example, if the entity's label is located in $entity->subject, then
 *       'subject' should be specified here. If complex logic is required to
 *       build the label, a 'label callback' should be defined instead (see
 *       the 'label callback' section above for details).
 *     - language: The name of the property, typically 'language', that contains
 *       the language code representing the language the entity has been created
 *       in. This value may be changed when editing the entity and represents
 *       the language its textual components are supposed to have. If no
 *       language property is available, the 'language callback' may be used
 *       instead. This entry can be omitted if the entities of this type are not
 *       language-aware.
 *   - bundle keys: An array describing how the Field API can extract the
 *     information it needs from the bundle objects for this type. This entry
 *     is required if the 'path' provided in the 'bundles'/'admin' section
 *     identifies the bundle using a named menu placeholder whose loader
 *     callback returns an object (e.g., $vocabulary for taxonomy terms, or
 *     $node_type for nodes). If the path does not include the bundle, or the
 *     bundle is just a string rather than an automatically loaded object, then
 *     this can be omitted. Elements:
 *     - bundle: The name of the property of the bundle object that contains
 *       the name of the bundle object.
 *   - bundles: An array describing all bundles for this object type. Keys are
 *     bundles machine names, as found in the objects' 'bundle' property
 *     (defined in the 'entity keys' entry above). This entry can be omitted if
 *     this entity type exposes a single bundle (all entities have the same
 *     collection of fields). The name of this single bundle will be the same as
 *     the entity type. Elements:
 *     - label: The human-readable name of the bundle.
 *     - uri callback: Same as the 'uri callback' key documented above for the
 *       entity type, but for the bundle only. When determining the URI of an
 *       entity, if a 'uri callback' is defined for both the entity type and
 *       the bundle, the one for the bundle is used.
 *     - admin: An array of information that allows Field UI pages to attach
 *       themselves to the existing administration pages for the bundle.
 *       Elements:
 *       - path: the path of the bundle's main administration page, as defined
 *         in hook_menu(). If the path includes a placeholder for the bundle,
 *         the 'bundle argument' and 'real path' keys below are required.
 *       - bundle argument: The position of the bundle placeholder in 'path', if
 *         any.
 *       - real path: The actual path (no placeholder) of the bundle's main
 *         administration page. This will be used to generate links.
 *       - access callback: As in hook_menu(). 'user_access' will be assumed if
 *         no value is provided.
 *       - access arguments: As in hook_menu().
 *   - view modes: An array describing the view modes for the entity type. View
 *     modes let entities be displayed differently depending on the context.
 *     For instance, a node can be displayed differently on its own page
 *     ('full' mode), on the home page or taxonomy listings ('teaser' mode), or
 *     in an RSS feed ('rss' mode). Modules taking part in the display of the
 *     entity (notably the Field API) can adjust their behavior depending on
 *     the requested view mode. An additional 'default' view mode is available
 *     for all entity types. This view mode is not intended for actual entity
 *     display, but holds default display settings. For each available view
 *     mode, administrators can configure whether it should use its own set of
 *     field display settings, or just replicate the settings of the 'default'
 *     view mode, thus reducing the amount of display configurations to keep
 *     track of. Keys of the array are view mode names. Each view mode is
 *     described by an array with the following key/value pairs:
 *     - label: The human-readable name of the view mode
 *     - custom settings: A boolean specifying whether the view mode should by
 *       default use its own custom field display settings. If FALSE, entities
 *       displayed in this view mode will reuse the 'default' display settings
 *       by default (e.g. right after the module exposing the view mode is
 *       enabled), but administrators can later use the Field UI to apply custom
 *       display settings specific to the view mode.
 *
 * @see entity_load()
 * @see hook_entity_info_alter()
 */

// TODO This should be done in order to do VBO on the ip field, but no time right now. 2017-07-13T08:09, aklump
// https://www.drupal.org/node/1282486
//VBO only supports entity (base or revision) table Implement hook_entity_info() and make your table an entity. Use EntityAPIController so that you don't need to write other boilerplate functions.

//function loft_core_users_entity_info()
//{
//    $return = array(
//        'loft_core_user' => array(
//            'label' => t('Loft Core User'),
//            'controller class' => 'EntityAPIController',
//            'base table' => 'loft_core_users',
//            'revision table' => null,
//            'uri callback' => 'loft_core_user_uri',
//            'fieldable' => false,
//            'translation' => array(),
//            'entity keys' => array(
//                'id' => 'id',
//                'revision' => null,
//                'bundle' => 'type',
//                'language' => 'language',
//            ),
//            'bundle keys' => array(
//                'bundle' => 'type',
//            ),
//            'bundles' => array(
//                'loft_core_user' => array(
//                    'label' => 'User',
//                    'admin' => array(
//                        'path' => 'admin/structure/types/manage/%loft_core_user_type',
//                        'real path' => 'admin/structure/types/manage/loft_core_user',
//                        'bundle argument' => 4,
//                        'access arguments' => array('loft_core_users:administer'),
//                    ),
//                ),
//            ),
//            'view modes' => array(
//                'full' => array(
//                    'label' => t('Full content'),
//                    'custom settings' => false,
//                ),
//            ),
//        ),
//    );
//
//    return $return;
//}

